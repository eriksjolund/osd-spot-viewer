<!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8">
        <title>osd-spot-viewer</title>
        <script src="https://openseadragon.github.io/openseadragon/openseadragon.min.js"></script>       
        <script src="http://eriksjolund.github.io/OpenSeadragonPaperjsOverlay/openseadragon-paperjs-overlay.js"></script>        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.9.24/paper-full.min.js"></script>


        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
          <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    </head>
    <body>

      <h2>Drag the circles with the mouse!</h2>

        <div id="osd" style="width: 1000px; height:800px;"></div>
        <script>                

function serialize_key_from_coordinates(x, y) {
    return x + ',' + y;
}
function get_circle_from_grid_coord(grid_x, grid_y, circles) {
    var coord_as_string = serialize_key_from_coordinates(grid_x, grid_y);
    return circles[ coord_as_string ];
}
function get_circle_from_spot(spot, circles) {
    return get_circle_from_grid_coord(spot.grid_x, spot.grid_y, circles);
}
function add_line_as_neighbour(line, spot, circles) {
    var circle = get_circle_from_spot(spot,circles);
    circle.neighbours.push(line);
}
var add_neightbour_line = function(current_spot, next_spot_key, grid_spots, circles, connectionLineLayer) {
    if (next_spot_key in grid_spots) {
        var from = new paper.Point(current_spot.pixel_x, current_spot.pixel_y);
        var to_spot = grid_spots[ next_spot_key ];
        var to = new paper.Point(to_spot.pixel_x, to_spot.pixel_y);
        connectionLineLayer.activate();
        var path = new paper.Path.Line(from, to);
        path.strokeColor = 'red';
        var radius_average = (to_spot.radius + current_spot.radius) / 2;
        path.strokeWidth = radius_average * 0.4; // Somehow relating the line width to the radius of the circles seams reasonable.
        path.visible = true;
        path.from_spot = current_spot;
        path.to_spot = to_spot;
        add_line_as_neighbour(path, current_spot, circles);
        add_line_as_neighbour(path, to_spot, circles);
    }
};

var jsondata = null;
function paintCircles(jsondata, circleLayer, connectionLineLayer, overlay, circles) {
    var spots_len = jsondata.spots.length;
    // grid_spots is a Javascript object that provides a mapping between
    // logical grid coordinates and the json spot data.
    // For instance, the coordinate x=0 y=0 is set like this:
    // grid_spots[ "0,0" ] = json_spot;
    var grid_spots = {};
    for (var i = 0; i < spots_len; i++) {
        var spot = jsondata.spots[i];
        var coord_as_string = serialize_key_from_coordinates(spot.grid_x, spot.grid_y);
        grid_spots[ serialize_key_from_coordinates(spot.grid_x, spot.grid_y) ] = spot;
    }
    function add_circle(spot, circleLayer, connectionLineLayer) {
        circleLayer.activate();
        var circle = new paper.Path.Circle(new paper.Point(spot.pixel_x, spot.pixel_y), spot.radius);
        circle.neighbours = [];
        circle.fillColor = 'red';
        circle.visible = true;
        circle.spot_is_selected = false;
        // To make it easy change the original data when the circle is being dragged,
        // we store a reference to the original spot data.
        circle.spot = spot; 
        circle.onMouseDown = function (event) {
            console.log("circle.onMouseDown" , "event.point.x = ", event.point.x , "event.point.y = ", event.point.y);
        };
        circle.onMouseEnter = function (circle, event) {
            circle.spot_is_selected = true;
                        circle.fillColor = 'green';
                                    paper.view.draw();
        }.bind(null, circle);
        circle.onMouseLeave = function (circle, event) {
            circle.spot_is_selected = false;
                        circle.fillColor = 'red';
                                    paper.view.draw();
        }.bind(null, circle);
        return circle;
    }
    for (var i = 0; i < spots_len; i++) {
        var spot = jsondata.spots[i];
        var circle = add_circle(spot, circleLayer);
        var coord_as_string = serialize_key_from_coordinates(spot.grid_x, spot.grid_y);
        circles[ coord_as_string ] = circle;
    }
    for (var i = 0; i < spots_len; i++) {
        var spot = jsondata.spots[i];
        var circle = get_circle_from_spot(spot, circles);

        var spot_to_the_under = spot.grid_y + 1;
        var spot_to_the_under_key = spot.grid_x + "," + spot_to_the_under;
        add_neightbour_line(spot, spot_to_the_under_key, grid_spots, circles, connectionLineLayer);

        var spot_to_the_right_x = spot.grid_x + 1;
        var spot_to_the_right_key = spot_to_the_right_x +  "," + spot.grid_y;
        add_neightbour_line(spot, spot_to_the_right_key, grid_spots, circles, connectionLineLayer);
    }
};
var hit_item = null;

function reset_line_ends_from_spot(line) {
    // Due to a bug with removeSegments()
    // https://github.com/paperjs/paper.js/issues/815
    // we have to use Paper.js 0.9.24 instead of Paper.js 0.9.25.
    // As of 2016-05-11 Paper.js 0.9.26 has not yet been released.
    // When it gets released we should try to upgrade.
    line.removeSegments();
    var seg = [new paper.Point(line.from_spot.pixel_x, line.from_spot.pixel_y),
               new paper.Point(line.to_spot.pixel_x, line.to_spot.pixel_y)];
    line.addSegments(seg);
}

function savejson(alink) {
    var url = "data:application/json;charset=utf-8,"  + encodeURIComponent(JSON.stringify(jsondata));
    alink.href = url;
};

function guiMode() {
    console.log(JSON.stringify($('#modeSelector input:radio:checked')));
    return $('#modeSelector input:radio:checked').prop('id');
    //return $('#modeSelector > .btn.active').prop('id');
};

function convert_to_paper_point(position) {
    var po = new OpenSeadragon.Point(position.x, position.y);
    var wp = window.viewer.viewport.viewerElementToImageCoordinates(po);
    return new paper.Point(wp.x, wp.y);
}

function point_is_over_selected_spot(point, circles) {
    var result = false;
    for (var key in circles) {
        var circle = circles[key];
        if (circle.spot_is_selected) {
            var res = circle.hitTest(point);
            if (res != null) {
                result = true;
                break;
            }
        }
    }
    return result;
}

window.onload = function() {
    var circles = {};
    var selection = {};
    selection.selected_spots_being_dragged = false;
    keyboard_status = {};
    keyboard_status.ctrl_key_is_down = false;
    var drag_handler = function(selection,  keyboard_status, circles, event) {
        var point = convert_to_paper_point(event.position);
        if (keyboard_status.ctrl_key_is_down && guiMode() == "lasso_selection_mode") {
            selection.selection_path.add(point);
            window.viewer.setMouseNavEnabled(false);
            paper.view.draw();
        } else {
            if (selection.selected_spots_being_dragged) {               
                window.viewer.setMouseNavEnabled(false);
                var transformed_point1 = paper.view.viewToProject(new paper.Point(0,0));
                var transformed_point2 = paper.view.viewToProject(new paper.Point(event.delta.x, event.delta.y));
                var diff = transformed_point2.subtract(transformed_point1);
                for (var key in circles) {
                    var circle = circles[key];
                    if (circle.spot_is_selected == true) {
                        circle.spot.pixel_x += diff.x;
                        circle.spot.pixel_y += diff.y;
                        // Instead of setting the position to a new point we could also do: "hit_item.position = hit_item.position.add(diff);"
                        // That might be faster, but resetting from original data is safer.
                        circle.position = new paper.Point(circle.spot.pixel_x, circle.spot.pixel_y);
                        for (var i = 0; i < circle.neighbours.length; i++) {
                            reset_line_ends_from_spot(circle.neighbours[i]);
                        }
                    }
                }
                paper.view.draw();
            }
        }
    }.bind(null, selection,  keyboard_status, circles);

    this.viewer = OpenSeadragon({
        id: "osd",
        prefixUrl: "https://openseadragon.github.io/openseadragon/images/",
        debugMode:  false,
        visibilityRatio: 1.0,
        constrainDuringPan: true,
        showNavigator: true,
        zoomPerScroll: 1.8
    });
    var overlay = this.viewer.paperjsOverlay();

    var connectionLineLayer = new paper.Layer();
    var circleLayer = new paper.Layer();
    document.getElementById('showLines').onchange=function(connectionLineLayer, visible) {
        connectionLineLayer.visible = visible.target.checked;
        paper.view.draw();
    }.bind(null, connectionLineLayer);
    
//    $('#modeSelector button')
    
    toggleShowLinesFunc = function(connectionLineLayer, visible) {
        connectionLineLayer.visible = visible;
        paper.view.draw();
    }.bind(null, connectionLineLayer);
    toggleSelectModeFunc = function(connectionLineLayer, visible) {
        connectionLineLayer.visible = visible;
        paper.view.draw();
    }.bind(null, connectionLineLayer);
    var key_up_handler = function(keyboard_status, event) {
        if (event.keyCode == 17) {
            keyboard_status.ctrl_key_is_down = false;
        }
    }.bind(null, keyboard_status);
    
    var press_handler = function(viewer, selection, circleLayer, keyboard_status, event) {
        
        if (guiMode() == "lasso_selection_mode") {
            console.log("lasso_selection_mode");
        }       
        if (keyboard_status.ctrl_key_is_down && guiMode() == "lasso_selection_mode") {
                selection.selection_path = new paper.Path();
                selection.selection_path.strokeColor = 'black';
                selection.selection_path.strokeWidth = 1;
                selection.selection_path.fillColor = 'blue';
                selection.selection_path.opacity = 0.5;
        } else {
            var point = convert_to_paper_point(event.position);
            if (point_is_over_selected_spot(point, circles)) {
                selection.selected_spots_being_dragged = true;
            }           
        }
    }.bind(null, this.viewer, selection, circleLayer, keyboard_status);
   
    var dragEnd_handler = function(selection, keyboard_status, circles, event) {
        if (keyboard_status.ctrl_key_is_down && guiMode() == "lasso_selection_mode") {
            var transformed_point = paper.view.viewToProject(new paper.Point(event.position.x, event.position.y));
            var hit_test_result = circleLayer.hitTest(transformed_point);
            for (var key in circles) {
                var circle = circles[key];
                var res = selection.selection_path.hitTest(circle.position);
                if (res != null) {              
                    circle.fillColor = 'green';
                    circle.spot_is_selected = true;
                }
            }
        }
        if (selection.selection_path != null) {
            selection.selection_path.remove();
            selection.selection_path = null;
        }
        selection.selected_spots_being_dragged = false;
        window.viewer.setMouseNavEnabled(true);
        hit_item = null;
    }.bind(null, selection, keyboard_status, circles);

    var key_down_handler = function(keyboard_status, circles, event) {
        if (event.keyCode == 32) { // 32 == space key
            for (var key in circles) {
                console.log("key down space : circle key =" + key);
                var circle = circles[key];
                circle.spot_is_selected = false;
                circle.fillColor = 'red';
                paper.view.draw();
            }
        }
        if (event.keyCode == 17) { // 17 == CTRL key
            keyboard_status.ctrl_key_is_down = true;
        }
    }.bind(null, keyboard_status, circles);

    var paint_circles_from_jsonfile = function(circleLayer, connectionLineLayer, overlay, circles, event) {
        overlay.resize();
        overlay.resizecanvas();
        var xhr = new XMLHttpRequest();
        // http://stackoverflow.com/questions/22356025/force-cache-control-no-cache-in-chrome-via-xmlhttprequest-on-f5-reload
        xhr.open('GET', 'spots.json?_=' + new Date().getTime());
        xhr.onload = function(circleLayer, connectionLineLayer, overlay, circles) {
            if (xhr.status === 200) {
                jsondata = JSON.parse(xhr.responseText);
                paintCircles(jsondata, circleLayer, connectionLineLayer, overlay, circles);
            } else {
                alert('Could not download json. xhr.status = ' + xhr.status);
            }
        }.bind(null, circleLayer, connectionLineLayer, overlay, circles);        xhr.send();
    }.bind(null, circleLayer, connectionLineLayer, overlay, circles);
    this.viewer.addTiledImage({
        tileSource: "http://openseadragon.github.io/example-images/highsmith/highsmith.dzi",
        x: 0,
        y: 0,
        success: paint_circles_from_jsonfile
    });
    new OpenSeadragon.MouseTracker({
        element: this.viewer.canvas,
        pressHandler: press_handler,
        dragHandler: drag_handler,
        dragEndHandler: dragEnd_handler,
        keyDownHandler: key_down_handler,
        keyUpHandler: key_up_handler
    }).setTracking(true);
    
    window.onresize = function() {
        overlay.resize();
        overlay.resizecanvas();
        //    paper.view.draw();
    };
    $('#normal').checked = true;
};

        </script>
        <div>
            <label for="showLines" >show connection lines</label> <input  id="showLines" type="checkbox"  checked="true">
        </div>

        <div class="btn-group" data-toggle="buttons" id="modeSelector">
          <label class="btn btn-primary active">

            <input type="radio" name="options" id="lasso_selection_mode"  checked="true">Lasso selection mode
</label>
          <label class="btn btn-primary">
            <input type="radio" name="options" id="hover_selection_mode">Hover selection mode
          </label>
          </div>

        <br/>   
        <a href="#"   onclick="savejson(this)" download="data.json" id="saveJSON" >save json</a>
    </body>
</html>
